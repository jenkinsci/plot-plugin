/*
 * Copyright (c) 2007-2009 Yahoo! Inc.  All rights reserved.
 * The copyrights to the contents of this file are licensed under the MIT License (http://www.opensource.org/licenses/mit-license.php)
 */

package hudson.plugins.plot;

import hudson.EnvVars;
import hudson.FilePath;
import hudson.model.AbstractProject;
import hudson.model.Build;
import hudson.model.BuildListener;

import java.io.File;
import java.io.IOException;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.kohsuke.stapler.DataBoundConstructor;

/**
 * Represents the configuration for a single plot.  A plot can
 * have one or more data series (lines).  Each data series 
 * has one data point per build.  The x-axis is always the
 * build number.
 * 
 * A plot has the following characteristics:
 * <ul>
 * <li> a title (mandatory)
 * <li> y-axis label (defaults to no label)
 * <li> one or more data series
 * <li> plot group (defaults to no group)
 * <li> number of builds to show on the plot (defaults to all)
 * </ul> 
 * 
 * A plots group affects the way in which plots are displayed.  Group names
 * are listed as links on the top-level plot page.  The user then clicks
 * on a group and sees the plots that belong to that group.
 * 
 * This class only represents the definition part of the plot.
 * The actual series of data generated and collected during a build are supported
 * by a ${link PlotData} class.
 * This is to make the clear separation of the definition and the instance of the plot.
 * The definition can contain variables (in the title for instance) that need to be expanded and stored
 * Also one definition will derive in multiple plots for the case of MatrixProjects
 * 
 * @author Nigel Daley
 */
public class Plot {
    private static final Logger LOGGER = Logger.getLogger(Plot.class.getName());
    
    // Transient values, ie not stored in the job definition

    /** Whether or not the plot has a legend. */
    private transient boolean hasLegend = true;

    /** Number of builds back to show on this plot from url. */
    public transient String urlNumBuilds;
    
    /** Title of plot from url. */
    public transient String urlTitle;

    /** Style of plot from url. */
    public transient String urlStyle;

    /** Use description flag from url. */
    public transient Boolean urlUseDescr;

    // Configuration values stored in the job definition
    
    /** Title of plot. Mandatory. */
    public String title;
    
    /** Y-axis label. Optional. */
    public String yaxis;

    /** Array of data series. */
    public Series[] series;

    /** Group name that this plot belongs to. */
    public String group;
    
    /** 
     * Number of builds back to show on this plot. 
     * Empty string means all builds.  Must not be "0".
     */
    public String numBuilds;
    
    /**
     * The name of the CSV file that persists the plots data.
     * The CSV file is stored in the projects root directory.
     * This is different from the source csv file that can be used as a source for the plot.
     */
    public String csvFileName;
    
    /** Optional style of plot: line, line3d, stackedArea, stackedBar, etc. */
    public String style;

    /** Whether or not to use build descriptions as X-axis labels. Optional. */
    public boolean useDescr;

    /**
     * Creates a new plot with the given parameters.  If numBuilds
     * is the empty string, then all builds will be included. Must
     * not be zero.
     */
    @DataBoundConstructor
    public Plot(String title, String yaxis,
            String group, String numBuilds, String csvFileName, String style, boolean useDescr)
    {
    	LOGGER.info("Constructing a Plot object with " + title);
        this.title = title;
        this.yaxis = yaxis;
        this.group = group;
        this.numBuilds = numBuilds;
        // Determines a name for the CSV File that will hold the data generated by the builds of this job
        // This filename will be a hidden configuration paramerter
        if (csvFileName == null || csvFileName.trim().length()==0) {
            csvFileName = "Plot_" + Math.abs(new Random().nextInt()) + ".csv";
        }
        this.csvFileName = csvFileName;
        this.style = style;
        this.useDescr = useDescr;
    }

    // needed for serialization
    public Plot() {}

    @Override
    public String toString() {
    	LOGGER.fine("Serializing the Plot[" + title + "]");
        return "TITLE("+getTitle()+
            "),YAXIS("+yaxis+
            "),NUMSERIES("+series.length+
            "),GROUP("+group+
            "),NUMBUILDS("+numBuilds+
            "),HASLEGEND("+hasLegend()+
            "),FILENAME("+csvFileName+")";
    }
    
    /** Getters for the different configuration options **/
    
    public String getYaxis() {
        return yaxis;
    }
    public Series[] getSeries() {
        return series;
    }
    public String getGroup() {
        return group;
    }
    public String getCsvFileName() {
        return csvFileName;
    }
    public boolean hasLegend() {
        return hasLegend;
    }
    public String getTitle() {
    	return title;
    }
    public String getNumBuilds() {
        return numBuilds;
    }
    
    /**
     * Called when a build completes. Adds the finished build to this plot.
     * This plot definition will instanciate a PlotData object and add the new data generated
     * by this build into it.
     * 
     * @param build
     * @param logger
     * @throws InterruptedException 
     * @throws IOException 
     */
    public void addBuild(Build<?, ?> build, BuildListener listener) throws IOException, InterruptedException {
    	LOGGER.entering(this.getClass().getName(), "addBuild");
    	
        // Get the environment from the build.
        EnvVars envVars = build.getEnvironment(listener);
    	
	    // extract the data for each data series
        for (Series series : getSeries()) {
        	if (series == null)
                continue;
        	PlotPoint[] seriesData = series.loadSeries(build.getWorkspace(),listener.getLogger());
            
        	// For all the plotData created from this plot definition, update the fields that can be variables
            // and also add the data from this build
        	PlotData plotData = getPlotData(build.getProject(), new FilePath(build.getProject().getRootDir()));
        	if(plotData == null) {
        		File csvFile = new File(build.getProject().getRootDir().getAbsolutePath(), getCsvFileName());
        		LOGGER.finest("Creating an empty PlotData with the file " + csvFile);
        		plotData = new PlotData(build.getProject(),new FilePath(csvFile));
    		}
        	LOGGER.finest("Expanding the variables in the title and yaxis");
    		plotData.setTitle(envVars.expand(this.title));
    		plotData.setYaxis(envVars.expand(this.yaxis));
    		plotData.addSeriesData(seriesData, build, listener);
    	}
        LOGGER.exiting(this.getClass().getName(), "addBuild");
    }

    /**
     * Get the PlotData created from this Plot definition
     * This is done by checking the existence of the CSV File in the project directory (not the workspace)
     * @param project The project to associate the data with
     * @param rootDir The rootdir of this project
     * @return The PlotData object or null if no data (yet)
     */
	public PlotData getPlotData(AbstractProject<?, ?> project, FilePath rootDir) {
		LOGGER.entering(this.getClass().getName(), "getPlotData");
		FilePath[] dataFiles = null;
		
		try {
			// Scans the root dir for a CSV File as configured
			LOGGER.fine("Looking for a CSV file named " + getCsvFileName() + " under " + rootDir.getName());
			dataFiles = rootDir.list(getCsvFileName());
		} catch (Exception e) {
			LOGGER.log(Level.SEVERE, "Exception when listing the CSV file.", e);
			e.printStackTrace();
		}
		if(dataFiles == null || dataFiles.length < 1 ) {
			LOGGER.info("The data file does not exist. This is normal if no build have been run yet");
			return null;
		}
		LOGGER.exiting(this.getClass().getName(), "getPlotData");
		return new PlotData(project, dataFiles[0]);
	}
}
